{"version":3,"names":["MESSAGE_TYPES","MESSAGE","PING","PONG","CALLBACK","DEBUG","ERRORS","SocketClient","connectHandlers","reconnectHandlers","disconnectHandlers","errorHandlers","handlers","wasConnected","connectTimer","connectingTimer","connectionCount","callbacks","pending","id","lastPong","socket","url","options","pingInterval","sessionID","authTimeout","connected","log","constructor","this","debug","text","console","Date","toISOString","warn","error","getQuery","_url","parts","split","result","p","length","decodeURIComponent","connect","clearInterval","window","location","href","JSON","parse","stringify","Error","pongTimeout","parseInt","connectTimeout","connectInterval","connectMaxAttempt","now","pathname","endsWith","pop","protocol","host","join","query","sid","Object","prototype","hasOwnProperty","call","u","replace","keys","map","attr","undefined","name","encodeURIComponent","token","WebSocket","forEach","cb","close","setTimeout","onopen","setInterval","send","e","_garbageCollect","onclose","event","code","onerror","readyState","type","onmessage","message","data","args","clearTimeout","findAnswer","emit","apply","empty","newCallback","i","push","withCallback","ts","callback","binary","bytes","Uint8Array","len","byteLength","String","fromCharCode","btoa","_args","eventHandler","on","off","pos","indexOf","splice","_reconnect","disconnect","destroy","socketClient","io"],"sources":["../../socket.io.ts"],"sourcesContent":["/*!\n * ioBroker WebSockets\n * Copyright 2020-2025, bluefox <dogafox@gmail.com>\n * Released under the MIT License.\n * v 2.1.0 (2025_03_05)\n */\ninterface ConnectOptions {\n    /** Connection name, so the backend knows who wants to connect. Optional */\n    name?: string;\n    /** Timeout for answer for ping (pong) */\n    pongTimeout?: number;\n    /** Ping interval */\n    pingInterval?: number;\n    /** connection request timeout */\n    connectTimeout?: number;\n    /** Authentication timeout */\n    authTimeout?: number;\n    /** Interval between connection attempts */\n    connectInterval?: number;\n    /** Every connection attempt the interval increasing at options.connectInterval till max this number */\n    connectMaxAttempt?: number;\n    /** Token for authentication */\n    token?: string;\n}\n\nconst MESSAGE_TYPES: Record<string, number> = {\n    MESSAGE: 0,\n    PING: 1,\n    PONG: 2,\n    CALLBACK: 3,\n};\n\nconst DEBUG = true;\n\nconst ERRORS: Record<number, string> = {\n    1000: 'CLOSE_NORMAL', // Successful operation / regular socket shutdown\n    1001: 'CLOSE_GOING_AWAY', // Client is leaving (browser tab closing)\n    1002: 'CLOSE_PROTOCOL_ERROR', // Endpoint received a malformed frame\n    1003: 'CLOSE_UNSUPPORTED', // Endpoint received an unsupported frame (e.g., binary-only endpoint received text frame)\n    1005: 'CLOSED_NO_STATUS', // Expected close status, received none\n    1006: 'CLOSE_ABNORMAL', // No close code frame has been received\n    1007: 'Unsupported payload', // Endpoint received an inconsistent message (e.g., malformed UTF-8)\n    1008: 'Policy violation', // Generic code used for situations other than 1003 and 1009\n    1009: 'CLOSE_TOO_LARGE', // Endpoint won't process large frame\n    1010: 'Mandatory extension', // Client wanted an extension which server did not negotiate\n    1011: 'Server error', // Internal server error while operating\n    1012: 'Service restart', // Server/service is restarting\n    1013: 'Try again later', // Temporary server condition forced blocking client's request\n    1014: 'Bad gateway\tServer', // acting as gateway received an invalid response\n    1015: 'TLS handshake fail', // Transport Layer Security handshake failure\n};\n\ntype SocketEventHandler = (...args: any[]) => void;\ntype SocketConnectionHandler = (connected: boolean) => void;\ntype SocketDisconnectionHandler = () => void;\ntype SocketErrorHandler = (err: string) => void;\n\n// possible events: connect, disconnect, reconnect, error, connect_error\nclass SocketClient {\n    private readonly connectHandlers: SocketConnectionHandler[] = [];\n    private readonly reconnectHandlers: SocketConnectionHandler[] = [];\n    private readonly disconnectHandlers: SocketDisconnectionHandler[] = [];\n    private readonly errorHandlers: SocketErrorHandler[] = [];\n\n    private readonly handlers: {\n        [event: string]: SocketEventHandler[];\n    } = {};\n    private wasConnected = false;\n    private connectTimer: ReturnType<typeof setTimeout> | null = null;\n    private connectingTimer: ReturnType<typeof setTimeout> | null = null;\n    private connectionCount = 0;\n    private callbacks: ({ ts: number; cb: SocketEventHandler; id: number } | null)[] = [];\n    private pending: { name: string; args: any[] }[] = []; // pending requests till connection established\n    private id = 0;\n    private lastPong: number = 0;\n    private socket: WebSocket | null = null;\n    private url: string = '';\n    private options: ConnectOptions | null = null;\n    private pingInterval: ReturnType<typeof setInterval> | null = null;\n    private sessionID = 0;\n    private authTimeout: ReturnType<typeof setTimeout> | null = null;\n\n    public connected = false;\n\n    private readonly log: {\n        debug: (text: string) => void;\n        warn: (text: string) => void;\n        error: (text: string) => void;\n    };\n\n    constructor() {\n        this.log = {\n            debug: (text: string) => DEBUG && console.log(`[${new Date().toISOString()}] ${text}`),\n            warn: (text: string) => console.warn(`[${new Date().toISOString()}] ${text}`),\n            error: (text: string) => console.error(`[${new Date().toISOString()}] ${text}`),\n        };\n    }\n\n    private static getQuery(_url: string): Record<string, string> {\n        const query = _url.split('?')[1] || '';\n        const parts = query.split('&');\n        const result: Record<string, string> = {};\n        for (let p = 0; p < parts.length; p++) {\n            const parts1 = parts[p].split('=');\n            result[parts1[0]] = decodeURIComponent(parts[1]);\n        }\n        return result;\n    }\n\n    connect(url?: string, options?: ConnectOptions): SocketClient {\n        this.log.debug('Try to connect');\n\n        // remove hash\n        if (url) {\n            url = url.split('#')[0];\n        }\n\n        this.id = 0;\n        this.connectTimer && clearInterval(this.connectTimer);\n        this.connectTimer = null;\n\n        this.url = this.url || url || window.location.href;\n        this.options = this.options || JSON.parse(JSON.stringify(options || {}));\n        if (!this.options) {\n            throw new Error('No options provided!');\n        }\n\n        this.options.pongTimeout = parseInt(this.options.pongTimeout as unknown as string, 10) || 60000; // Timeout for answer for ping (pong)\n        this.options.pingInterval = parseInt(this.options.pingInterval as unknown as string, 10) || 5000; // Ping interval\n        this.options.connectTimeout = parseInt(this.options.connectTimeout as unknown as string, 10) || 3000; // connection request timeout\n        this.options.authTimeout = parseInt(this.options.authTimeout as unknown as string, 10) || 3000; // Authentication timeout\n        this.options.connectInterval = parseInt(this.options.connectInterval as unknown as string, 10) || 1000; // Interval between connection attempts\n        this.options.connectMaxAttempt = parseInt(this.options.connectMaxAttempt as unknown as string, 10) || 5; // Every connection attempt the interval increasing at options.connectInterval till max this number\n\n        this.sessionID = Date.now();\n        try {\n            if (this.url === '/') {\n                const parts = window.location.pathname.split('/');\n                // remove filename\n                if (window.location.pathname.endsWith('.html') || window.location.pathname.endsWith('.htm')) {\n                    parts.pop();\n                }\n\n                this.url = `${window.location.protocol}//${window.location.host}/${parts.join('/')}`;\n            }\n\n            // extract all query attributes\n            const query = SocketClient.getQuery(this.url);\n            if (query.sid) {\n                delete query.sid;\n            }\n\n            if (Object.prototype.hasOwnProperty.call(query, '')) {\n                delete query[''];\n            }\n\n            let u = `${this.url.replace(/^http/, 'ws').split('?')[0]}?sid=${this.sessionID}`;\n\n            // Apply a query to new url\n            if (Object.keys(query).length) {\n                u += `&${Object.keys(query)\n                    .map(attr => (query[attr] === undefined ? attr : `${attr}=${query[attr]}`))\n                    .join('&')}`;\n            }\n\n            if (this.options?.name && !query.name) {\n                u += `&name=${encodeURIComponent(this.options.name)}`;\n            }\n            if (this.options?.token) {\n                u += `&token=${this.options.token}`;\n            }\n            // \"ws://www.example.com/socketserver\"\n            this.socket = new WebSocket(u);\n        } catch (error) {\n            this.handlers.error?.forEach(cb => cb.call(this, error));\n            this.close();\n            return this;\n        }\n\n        this.connectingTimer = setTimeout(() => {\n            this.connectingTimer = null;\n            this.log.warn('No READY flag received in 3 seconds. Re-init');\n            this.close(); // re-init connection, because no ___ready___ received in 2000 ms\n        }, this.options.connectTimeout);\n\n        this.socket.onopen = (): void /*event*/ => {\n            this.lastPong = Date.now();\n            this.connectionCount = 0;\n\n            this.pingInterval = setInterval((): void => {\n                if (!this.options) {\n                    throw new Error('No options provided!');\n                }\n\n                if (Date.now() - this.lastPong > (this.options?.pingInterval || 5000) - 10) {\n                    try {\n                        this.socket?.send(JSON.stringify([MESSAGE_TYPES.PING]));\n                    } catch (e) {\n                        this.log.warn(`Cannot send ping. Close connection: ${e}`);\n                        this.close();\n                        this._garbageCollect();\n                        return;\n                    }\n                }\n                if (Date.now() - this.lastPong > (this.options?.pongTimeout || 60000)) {\n                    this.close();\n                }\n                this._garbageCollect();\n            }, this.options?.pingInterval || 5000);\n        };\n\n        this.socket.onclose = (event: CloseEvent): void => {\n            if (event.code === 3001) {\n                this.log.warn('ws closed');\n            } else {\n                this.log.error(`ws connection error: ${ERRORS[event.code]}`);\n            }\n            this.close();\n        };\n\n        // @ts-expect-error invalid typing\n        this.socket.onerror = (error: CloseEvent): void => {\n            if (this.connected && this.socket) {\n                if (this.socket.readyState === 1) {\n                    this.log.error(`ws normal error: ${error.type}`);\n                }\n                this.errorHandlers.forEach(cb => cb.call(this, ERRORS[error.code] || 'UNKNOWN'));\n            }\n            this.close();\n        };\n\n        this.socket.onmessage = (message: MessageEvent<string>): void => {\n            this.lastPong = Date.now();\n            if (!message?.data || typeof message.data !== 'string') {\n                console.error(`Received invalid message: ${JSON.stringify(message)}`);\n                return;\n            }\n            let data;\n            try {\n                data = JSON.parse(message.data);\n            } catch {\n                console.error(`Received invalid message: ${JSON.stringify(message.data)}`);\n                return;\n            }\n\n            const type: number = data[0];\n            const id: number = data[1];\n            const name: string = data[2];\n            const args: any[] = data[3];\n\n            if (this.authTimeout) {\n                clearTimeout(this.authTimeout);\n                this.authTimeout = null;\n            }\n\n            if (type === MESSAGE_TYPES.CALLBACK) {\n                this.findAnswer(id, args);\n            } else if (type === MESSAGE_TYPES.MESSAGE) {\n                if (name === '___ready___') {\n                    this.connected = true;\n\n                    if (this.wasConnected) {\n                        this.reconnectHandlers.forEach(cb => cb.call(this, true));\n                    } else {\n                        this.connectHandlers.forEach(cb => cb.call(this, true));\n                        this.wasConnected = true;\n                    }\n\n                    this.connectingTimer && clearTimeout(this.connectingTimer);\n                    this.connectingTimer = null;\n\n                    // resend all pending requests\n                    if (this.pending.length) {\n                        this.pending.forEach(({ name, args }) => this.emit(name, ...args));\n\n                        this.pending = [];\n                    }\n                } else if (args) {\n                    this.handlers[name]?.forEach(cb => cb.apply(this, args));\n                } else {\n                    this.handlers[name]?.forEach(cb => cb.call(this));\n                }\n            } else if (type === MESSAGE_TYPES.PING) {\n                if (this.socket) {\n                    this.socket.send(JSON.stringify([MESSAGE_TYPES.PONG]));\n                } else {\n                    this.log.warn('Cannot do pong: connection closed');\n                }\n            } else if (type === MESSAGE_TYPES.PONG) {\n                // lastPong saved\n            } else {\n                this.log.warn(`Received unknown message type: ${type}`);\n            }\n        };\n\n        return this;\n    }\n\n    private _garbageCollect(): void {\n        const now = Date.now();\n        let empty = 0;\n        if (!DEBUG) {\n            for (let i = 0; i < this.callbacks.length; i++) {\n                const callback: { ts: number; cb: SocketEventHandler; id: number } | null = this.callbacks[i];\n                if (callback) {\n                    if (callback.ts > now) {\n                        const cb = callback.cb;\n                        setTimeout(cb, 0, 'timeout');\n                        this.callbacks[i] = null;\n                        empty++;\n                    } // else callback is still valid\n                } else {\n                    empty++;\n                }\n            }\n        }\n\n        // remove nulls\n        if (empty > this.callbacks.length / 2) {\n            const newCallback = [];\n            for (let i = 0; i < this.callbacks.length; i++) {\n                this.callbacks[i] && newCallback.push(this.callbacks[i]);\n            }\n            this.callbacks = newCallback;\n        }\n    }\n\n    private withCallback(name: string, id: number, args: any[], cb: SocketEventHandler): void {\n        if (name === 'authenticate') {\n            this.authTimeout = setTimeout(() => {\n                this.authTimeout = null;\n                if (this.connected) {\n                    this.log.debug('Authenticate timeout');\n                    this.handlers.error?.forEach(cb => cb.call(this, 'Authenticate timeout'));\n                }\n                this.close();\n            }, this.options?.authTimeout || 3000);\n        }\n        this.callbacks.push({ id, cb, ts: DEBUG ? 0 : Date.now() + 30000 });\n        this.socket?.send(JSON.stringify([MESSAGE_TYPES.CALLBACK, id, name, args]));\n    }\n\n    private findAnswer(id: number, args: any[]): void {\n        for (let i = 0; i < this.callbacks.length; i++) {\n            const callback = this.callbacks[i];\n            if (callback?.id === id) {\n                const cb = callback.cb;\n                cb.call(null, ...args);\n                this.callbacks[i] = null;\n            }\n        }\n    }\n\n    emit = (name: string, ...args: any[]): void => {\n        if (!this.socket || !this.connected) {\n            if (!this.wasConnected) {\n                // cache all calls till connected\n                this.pending.push({ name, args });\n            } else {\n                this.log.warn('Not connected');\n            }\n            return;\n        }\n\n        this.id++;\n\n        if (name === 'writeFile' && args && typeof args[2] !== 'string' && args[2]) {\n            // Arguments: arg1,     arg2,     arg3, arg4\n            // Arguments: _adapter, filename, data, callback\n            let binary = '';\n            const bytes = new Uint8Array(args[2]);\n            const len = bytes.byteLength;\n            for (let i = 0; i < len; i++) {\n                binary += String.fromCharCode(bytes[i]);\n            }\n            args[2] = window.btoa(binary);\n        }\n\n        try {\n            // if the last argument is a function\n            if (args && typeof args[args.length - 1] === 'function') {\n                const _args = [...args];\n                const eventHandler: SocketEventHandler = _args.pop();\n                this.withCallback(name, this.id, _args, eventHandler);\n            } else if (!args?.length) {\n                this.socket.send(JSON.stringify([MESSAGE_TYPES.MESSAGE, this.id, name]));\n            } else {\n                this.socket.send(JSON.stringify([MESSAGE_TYPES.MESSAGE, this.id, name, args]));\n            }\n        } catch (e) {\n            console.error(`Cannot send: ${e}`);\n            this.close();\n        }\n    };\n\n    on(\n        name: string,\n        cb: SocketEventHandler | SocketErrorHandler | SocketDisconnectionHandler | SocketConnectionHandler,\n    ): void {\n        if (cb) {\n            if (name === 'connect') {\n                this.connectHandlers.push(cb as SocketConnectionHandler);\n            } else if (name === 'disconnect') {\n                this.disconnectHandlers.push(cb as SocketDisconnectionHandler);\n            } else if (name === 'reconnect') {\n                this.reconnectHandlers.push(cb as SocketConnectionHandler);\n            } else if (name === 'error') {\n                this.errorHandlers.push(cb as SocketErrorHandler);\n            } else {\n                this.handlers[name] = this.handlers[name] || [];\n                this.handlers[name].push(cb as SocketEventHandler);\n            }\n        }\n    }\n\n    off(\n        name: string,\n        cb: SocketEventHandler | SocketErrorHandler | SocketDisconnectionHandler | SocketConnectionHandler,\n    ): void {\n        if (name === 'connect') {\n            const pos = this.connectHandlers.indexOf(cb as SocketConnectionHandler);\n            if (pos !== -1) {\n                this.connectHandlers.splice(pos, 1);\n            }\n        } else if (name === 'disconnect') {\n            const pos = this.disconnectHandlers.indexOf(cb as SocketDisconnectionHandler);\n            if (pos !== -1) {\n                this.disconnectHandlers.splice(pos, 1);\n            }\n        } else if (name === 'reconnect') {\n            const pos = this.reconnectHandlers.indexOf(cb as SocketConnectionHandler);\n            if (pos !== -1) {\n                this.reconnectHandlers.splice(pos, 1);\n            }\n        } else if (name === 'error') {\n            const pos = this.errorHandlers.indexOf(cb as SocketErrorHandler);\n            if (pos !== -1) {\n                this.errorHandlers.splice(pos, 1);\n            }\n        } else if (this.handlers[name]) {\n            const pos = this.handlers[name].indexOf(cb as SocketEventHandler);\n            if (pos !== -1) {\n                this.handlers[name].splice(pos, 1);\n                if (!this.handlers[name].length) {\n                    delete this.handlers[name];\n                }\n            }\n        }\n    }\n\n    close(): SocketClient {\n        this.pingInterval && clearInterval(this.pingInterval);\n        this.pingInterval = null;\n\n        this.authTimeout && clearTimeout(this.authTimeout);\n        this.authTimeout = null;\n\n        this.connectingTimer && clearTimeout(this.connectingTimer);\n        this.connectingTimer = null;\n\n        if (this.socket) {\n            try {\n                this.socket.close();\n            } catch {\n                // ignore\n            }\n            this.socket = null;\n        }\n\n        if (this.connected) {\n            this.disconnectHandlers.forEach(cb => cb.call(this));\n            this.connected = false;\n        }\n\n        this.callbacks = [];\n\n        this._reconnect();\n\n        return this;\n    }\n\n    // alias for back compatibility\n    disconnect = this.close;\n\n    destroy(): void {\n        this.close();\n        this.connectTimer && clearTimeout(this.connectTimer);\n        this.connectTimer = null;\n    }\n\n    private _reconnect(): void {\n        if (!this.connectTimer) {\n            this.log.debug(`Start reconnect ${this.connectionCount}`);\n            this.connectTimer = setTimeout(\n                () => {\n                    if (!this.options) {\n                        throw new Error('No options provided!');\n                    }\n                    this.connectTimer = null;\n                    if (this.connectionCount < (this.options?.connectMaxAttempt || 5)) {\n                        this.connectionCount++;\n                    }\n                    this.connect(this.url, this.options);\n                },\n                this.connectionCount * (this.options?.connectInterval || 1000),\n            );\n        } else {\n            this.log.debug(`Reconnect is already running ${this.connectionCount}`);\n        }\n    }\n}\n\n// every time creates a new socket\nfunction connect(url?: string, options?: ConnectOptions): SocketClient {\n    const socketClient = new SocketClient();\n    socketClient.connect(url, options);\n    return socketClient;\n}\n\nwindow.io = {\n    connect,\n};\n"],"mappings":"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","ignoreList":[]}