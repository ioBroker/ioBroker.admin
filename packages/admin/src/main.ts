/**
 *      Admin backend
 *
 *      Controls Adapter-Processes
 *
 *      Copyright 2014-2024 Denis Haev <dogafox@gmail.com>,
 *      MIT License
 *
 */

import * as semver from 'semver';
import axios from 'axios';
import * as fs from 'node:fs';
import * as os from 'node:os';
import * as path from 'node:path';
import * as crypto from 'node:crypto';

import * as utils from '@iobroker/adapter-core';
// @ts-expect-error it not TS
import { SocketAdmin } from '@iobroker/socket-classes';
// @ts-expect-error it not TS
import * as ws from '@iobroker/ws-server';
import { getAdapterUpdateText } from './lib/translations';
import Web, { type AdminAdapterConfig } from './lib/web';

const adapterName = JSON.parse(fs.readFileSync(path.join(__dirname, '..', 'package.json'), { encoding: 'utf-8' }))
    .name.split('.')
    .pop();
// eslint-disable-next-line @typescript-eslint/no-var-requires

const { getInstalledInfo } = utils.commonTools;

const ONE_HOUR_MS = 3_600_000;
const ERROR_PERMISSION = 'permissionError';

const CURRENT_MAX_MAJOR_NODEJS = 20;
const CURRENT_MAX_MAJOR_NPM = 8;

let socket: typeof SocketAdmin;
let webServer: Web;
let lastRepoUpdate: number;

// TODO: these are not just state objects adjust later
let objects: Record<string, ioBroker.StateObject> = {};
const secret = 'Zgfr56gFe87jJOM'; // Will be generated by first start
let systemLanguage: ioBroker.Languages = 'en';

interface UpdateInfo {
    /** Current available version in repository */
    availableVersion: string;
    /** Current installed version */
    installedVersion: string;
}

interface NodeVersionInformation {
    /** Node.js version */
    version: string;
    /** npm version */
    npm: string;
}

interface NewsMessage {
    id: string;
    'date-start': string;
    'date-end': string;
    created: string;
    'node-version': string;
    'npm-version': string;
    conditions: Record<string, string>;
    os: string;
    repo: string;
    uuid: string;
    'number-of-objects': string;
    'objects-db-type': string;
    class: string;
    title: ioBroker.Translated;
    content: ioBroker.Translated;
}

class Admin extends utils.Adapter {
    public declare config: AdminAdapterConfig;

    /** secret used for the socket connection */
    public secret: string;

    /** Timer to update repository */
    private timerRepo: NodeJS.Timeout;

    private updaterTimeout: NodeJS.Timeout;

    private ratingTimeout: NodeJS.Timeout;

    private timerNews: NodeJS.Timeout;

    private _running: boolean;

    private _tasks: ioBroker.AnyObject[];

    constructor(options: Partial<utils.AdapterOptions> = {}) {
        options = {
            ...options,
            name: adapterName, // adapter name
            logTransporter: true, // receive the logs
            systemConfig: true,
            install: () => void null,
        };

        super(options as utils.AdapterOptions);

        this.on('objectChange', this.onObjectChange.bind(this));
        this.on('stateChange', this.onStateChange.bind(this));
        this.on('ready', this.onReady.bind(this));
        this.on('message', this.onMessage.bind(this));
        this.on('unload', this.onUnload.bind(this));
        this.on('fileChange', this.onFileChange.bind(this));
        this.on('log', this.onLog.bind(this));
    }

    /**
     * Is called if a subscribed object changes
     * @param id
     * @param obj
     */
    onObjectChange(id: string, obj: ioBroker.Object | null | undefined): void {
        if (obj) {
            objects[id] = obj as ioBroker.StateObject;

            if (id === 'system.config' && !this.config.language) {
                if (obj.common?.language) {
                    systemLanguage = obj.common.language;
                    if (webServer) {
                        webServer.setLanguage(systemLanguage);
                    }
                }
            }

            if (id === 'system.repositories' || id.match(/^system\.adapter\.[^.]+$/)) {
                if (this.updaterTimeout) {
                    clearTimeout(this.updaterTimeout);
                }
                this.updaterTimeout = setTimeout(() => {
                    this.updaterTimeout = null;
                    this.writeUpdateInfo();
                }, 5_000);
            }
        } else {
            // console.log('objectDeleted: ' + id);
            if (objects[id]) {
                delete objects[id];
            }
        }

        // TODO Build in some threshold of messages
        socket?.objectChange(id, obj);
    }

    /**
     * Is called if a subscribed state was changed
     * @param id
     * @param state
     */
    onStateChange(id: string, state: ioBroker.State | null | undefined): void {
        if (socket) {
            socket.stateChange(id, state);
        }
    }

    onFileChange(id: string, fileName: string, size: number): void {
        if (socket) {
            socket.fileChange(id, fileName, size);
        }
    }

    /**
     * Is called when databases are connected and adapter received configuration.
     */
    onReady(): void {
        this.getForeignObject('system.config', (err, obj) => {
            if (!err && obj) {
                obj.native = obj.native || {};
                if (this.config.language) {
                    systemLanguage = this.config.language;
                } else if (obj.common?.language) {
                    systemLanguage = obj.common.language;
                }

                if (!obj.native.secret) {
                    crypto.randomBytes(24, (_ex, buf) => {
                        this.secret = buf.toString('hex');
                        this.extendForeignObject('system.config', { native: { secret: this.secret } });
                        this.init();
                    });
                } else {
                    this.secret = obj.native.secret;
                    this.init();
                }
            } else {
                this.secret = secret;
                this.log.error('Cannot find object system.config');
            }
        });
    }

    /**
     * Some message was sent to this instance over the message box. Used by email, pushover, text2speech, ...
     * Using this method requires "common.messagebox" property to be set to true in io-package.json
     * @param obj
     */
    onMessage(obj: ioBroker.Message): void {
        if (!obj) {
            return;
        }
        if (obj.command === 'im') {
            // if not instance message
            socket.publishInstanceMessageAll(obj.from, obj.message.m, obj.message.s, obj.message.d);
        } else if (obj.command === 'checkFiles') {
            if (typeof obj.message === 'string') {
                try {
                    return (
                        obj.callback &&
                        this.sendTo(obj.from, obj.command, { result: fs.existsSync(obj.message) }, obj.callback)
                    );
                } catch (e) {
                    return obj.callback && this.sendTo(obj.from, obj.command, { error: e.message }, obj.callback);
                }
            } else if (Array.isArray(obj.message)) {
                const result: Record<string, boolean> = {};
                for (let f = 0; f < obj.message.length; f++) {
                    try {
                        result[obj.message[f]] = fs.existsSync(obj.message[f]);
                    } catch (e) {
                        result[obj.message[f]] = e.message;
                    }
                }
                return obj.callback && this.sendTo(obj.from, obj.command, result, obj.callback);
            }
        } else if (obj.command === 'autocomplete') {
            // just for test
            return (
                obj.callback &&
                this.sendTo(
                    obj.from,
                    obj.command,
                    [
                        { value: 1, label: 'first' },
                        { value: 2, label: 'second' },
                    ],
                    obj.callback
                )
            );
        } else if (obj.command === 'selectSendTo') {
            this.log.info(`SelectSendTo: ${JSON.stringify(obj.message)}`);
            // just for test
            return (
                obj.callback &&
                this.sendTo(
                    obj.from,
                    obj.command,
                    [
                        { label: 'Afghanistan', value: 'AF' },
                        { label: 'Åland Islands', value: 'AX' },
                        { label: 'Albania', value: 'AL' },
                    ],
                    obj.callback
                )
            );
        } else if (obj.command === 'url') {
            this.log.info(`url: ${JSON.stringify(obj.message)}`);
            // just for test
            return (
                obj.callback &&
                this.sendTo(obj.from, obj.command, { openUrl: obj.message._origin, saveConfig: true }, obj.callback)
            );
        }

        if (socket) {
            socket.sendCommand(obj);
        }
    }

    /**
     * Is called when adapter shuts down - callback has to be called under any circumstances!
     * @param callback
     */
    onUnload(callback: () => void): void {
        if (this.timerRepo) {
            clearTimeout(this.timerRepo);
            this.timerRepo = null;
        }

        if (this.timerNews) {
            clearTimeout(this.timerNews);
            this.timerNews = null;
        }

        if (this.ratingTimeout) {
            clearTimeout(this.ratingTimeout);
            this.ratingTimeout = null;
        }

        if (this.updaterTimeout) {
            clearTimeout(this.updaterTimeout);
            this.updaterTimeout = null;
        }

        try {
            this.log.info(`terminating http${this.config.secure ? 's' : ''} server on port ${this.config.port}`);
            socket?.close();
            webServer.close();
            callback();
        } catch {
            callback();
        }
    }

    onLog(obj: Record<string, unknown>): void {
        if (socket) {
            socket.sendLog(obj);
        }
    }

    async createUpdateInfo(): Promise<void> {
        const promises = [];
        // create connected object and state
        const updatesNumberObj = objects[`${this.namespace}.info.updatesNumber`];

        if (!updatesNumberObj || !updatesNumberObj.common || updatesNumberObj.common.type !== 'number') {
            const obj: ioBroker.StateObject = {
                _id: 'info.updatesNumber',
                type: 'state',
                common: {
                    role: 'indicator.updates',
                    name: {
                        en: 'Number of adapters to update',
                        de: 'Anzahl der zu aktualisierenden Adapter',
                        ru: 'Количество адаптеров для обновления',
                        pt: 'Número de adaptadores para atualizar',
                        nl: 'Aantal adapters om te updaten',
                        fr: "Nombre d'adaptateurs à mettre à jour",
                        it: 'Numero di adattatori da aggiornare',
                        es: 'Número de adaptadores para actualizar',
                        pl: 'Liczba adapterów do aktualizacji',
                        uk: 'Кількість адаптерів для оновлення',
                        'zh-cn': '要更新的适配器数量',
                    },
                    type: 'number',
                    read: true,
                    write: false,
                    def: 0,
                },
                native: {},
            };

            this.setObject(obj._id, obj);
        }

        const updatesListObj = objects[`${this.namespace}.info.updatesList`];

        if (!updatesListObj || !updatesListObj.common || updatesListObj.common.type !== 'string') {
            const obj: ioBroker.StateObject = {
                _id: 'info.updatesList',
                type: 'state',
                common: {
                    role: 'indicator.updates',
                    name: {
                        en: 'List of adapters to update',
                        de: 'Liste der zu aktualisierenden Adapter',
                        ru: 'Список адаптеров для обновления',
                        pt: 'Lista de adaptadores para atualizar',
                        nl: 'Lijst met adapters die moeten worden bijgewerkt',
                        fr: 'Liste des adaptateurs à mettre à jour',
                        it: 'Elenco degli adattatori da aggiornare',
                        es: 'Lista de adaptadores para actualizar',
                        pl: 'Lista adapterów do aktualizacji',
                        uk: 'Список адаптерів для оновлення',
                        'zh-cn': '要更新的适配器列表',
                    },
                    type: 'string',
                    read: true,
                    write: false,
                    def: '',
                },
                native: {},
            };

            this.setObject(obj._id, obj);
        }

        const newUpdatesObj = objects[`${this.namespace}.info.newUpdates`];

        if (!newUpdatesObj || !newUpdatesObj.common || newUpdatesObj.common.type !== 'boolean') {
            const obj: ioBroker.StateObject = {
                _id: 'info.newUpdates',
                type: 'state',
                common: {
                    role: 'indicator.updates',
                    name: {
                        en: 'Indicator if new adapter updates are available',
                        de: 'Anzeige, ob neue Adapter-Updates verfügbar sind',
                        ru: 'Индикатор наличия новых обновлений адаптера',
                        pt: 'Indicador se novas atualizações do adaptador estão disponíveis',
                        nl: 'Indicator of er nieuwe adapter-updates beschikbaar zijn',
                        fr: "Indicateur si de nouvelles mises à jour de l'adaptateur sont disponibles",
                        it: "Indicatore se sono disponibili nuovi aggiornamenti dell'adattatore",
                        es: 'Indicador si hay nuevas actualizaciones de adaptadores disponibles',
                        pl: 'Wskaźnik, czy dostępne są nowe aktualizacje adaptera',
                        uk: 'Індикатор наявності нових оновлень адаптера',
                        'zh-cn': '指示是否有新的适配器更新可用',
                    },
                    type: 'boolean',
                    read: true,
                    write: false,
                    def: false,
                },
                native: {},
            };

            promises.push(this.setObjectAsync(obj._id, obj));
        }

        const updatesJsonObj = objects[`${this.namespace}.info.updatesJson`];

        if (!updatesJsonObj || !updatesJsonObj.common || updatesJsonObj.common.type !== 'string') {
            const obj: ioBroker.StateObject = {
                _id: 'info.updatesJson',
                type: 'state',
                common: {
                    role: 'indicator.updates',
                    name: {
                        en: 'JSON string with adapter update information',
                        de: 'JSON-String mit Adapteraktualisierungsinformationen',
                        ru: 'Строка JSON с информацией об обновлении адаптера',
                        pt: 'String JSON com informações de atualização do adaptador',
                        nl: 'JSON-tekenreeks met adapter-update-informatie',
                        fr: "Chaîne JSON avec les informations de mise à jour de l'adaptateur",
                        it: "Stringa JSON con informazioni sull'aggiornamento dell'adattatore",
                        es: 'Cadena JSON con información de actualización del adaptador',
                        pl: 'Ciąg JSON z informacjami o aktualizacji adaptera',
                        uk: 'Рядок JSON з інформацією про оновлення адаптера',
                        'zh-cn': '带有适配器更新信息的 JSON 字符串',
                    },
                    type: 'string',
                    read: true,
                    write: false,
                    def: '{}',
                },
                native: {},
            };

            promises.push(this.setObjectAsync(obj._id, obj));
        }

        const lastUpdateCheckObj = objects[`${this.namespace}.info.lastUpdateCheck`];

        if (!lastUpdateCheckObj || !lastUpdateCheckObj.common || lastUpdateCheckObj.common.type !== 'number') {
            const obj: ioBroker.StateObject = {
                _id: 'info.lastUpdateCheck',
                type: 'state',
                common: {
                    role: 'value.time',
                    name: {
                        en: 'Timestamp of last update check',
                        de: 'Zeitstempel der letzten UpdatePrüfung',
                        ru: 'Отметка времени последней проверки обнвлений',
                        pt: 'Timestamp da última verificação de atualizaçã',
                        nl: 'Tijdstempel van laatste updatecontrole',
                        fr: 'Horodatage de la dernière vérificationde mise à jour',
                        it: "Timestamp dell'ultimo controllo di aggiornamento",
                        es: 'Marca de tiempo de la última verificación de actalización',
                        pl: 'Znacznik czasu ostatniego sprawdzenia aktualizacji',
                        uk: 'Відмітка часу останньої перевірки оновлень',
                        'zh-cn': '上次更新检查的时间戳',
                    },
                    type: 'number',
                    read: true,
                    write: false,
                    def: 0,
                },
                native: {},
            };

            promises.push(this.setObjectAsync(obj._id, obj));
        }

        await Promise.all(promises);
    }

    upToDate(v1: string, v2: string): boolean {
        return semver.gt(v2, v1);
    }

    /**
     * Write the update information to the states
     */
    writeUpdateInfo(
        /** current sources, if given */
        sources?: Record<string, ioBroker.RepositoryJsonAdapterContent>
    ): void {
        if (!objects['system.config'] || !objects['system.config'].common) {
            return this.log.warn('Repository cannot be read. Invalid "system.config" object.');
        }
        const { activeRepo } = (objects['system.config'] as unknown as ioBroker.SystemConfigObject).common;
        const systemRepos = objects['system.repositories'];

        if (!sources) {
            sources = {};

            // If multi-repo case
            if (Array.isArray(activeRepo)) {
                if (systemRepos?.native?.repositories) {
                    activeRepo.forEach(repo => {
                        if (systemRepos.native.repositories[repo]?.json) {
                            Object.assign(sources, systemRepos.native.repositories[repo].json);
                        } else {
                            this.setState('info.updatesNumber', 0, true);
                            this.setState('info.updatesList', '', true);
                            this.setState('info.newUpdates', false, true);
                            this.setState('info.updatesJson', '{}', true);
                            this.setState('info.lastUpdateCheck', Date.now(), true);
                            if (systemRepos.native.repositories[repo]) {
                                this.log.warn(`Repository cannot be read: Active repo - ${repo}`);
                            } else {
                                this.log.warn('No repository source configured');
                            }
                        }
                    });
                }
            } else if (systemRepos?.native?.repositories?.[activeRepo]?.json) {
                sources = systemRepos.native.repositories[activeRepo].json;
            }
        }

        if (!Object.keys(sources).length) {
            this.setState('info.updatesNumber', 0, true);
            this.setState('info.updatesList', '', true);
            this.setState('info.newUpdates', false, true);
            this.setState('info.updatesJson', '{}', true);
            this.setState('info.lastUpdateCheck', Date.now(), true);
            if (Array.isArray(activeRepo)) {
                let found = false;
                if (systemRepos?.native?.repositories) {
                    activeRepo.forEach(repo => {
                        if (systemRepos.native.repositories[repo]) {
                            this.log.warn(`Active repository "${repo}" cannot be read`);
                            found = true;
                        }
                    });
                }
                if (!found) {
                    this.log.warn(
                        `No repository source configured. Possible values: ${
                            systemRepos?.native?.repositories
                                ? Object.keys(systemRepos.native.repositories).join(', ')
                                : 'none'
                        }. Active repo(s): "${activeRepo.join('", "')}"`
                    );
                }
            } else if (systemRepos?.native?.repositories?.[activeRepo]) {
                this.log.warn(`Repository cannot be read. Active repo: ${activeRepo}`);
            } else {
                this.log.warn(
                    `No repository source configured. Possible values: ${
                        systemRepos?.native?.repositories
                            ? Object.keys(systemRepos.native.repositories).join(', ')
                            : 'none'
                    }. Active repo: "${activeRepo}"`
                );
            }
            return;
        }

        const installed = getInstalledInfo();
        const list: string[] = [];
        const updatesJson: Record<string, UpdateInfo> = {};
        let newUpdateIndicator = false;

        this.getState('info.updatesJson', (_err, state) => {
            let oldUpdates;
            if (typeof state?.val === 'string') {
                try {
                    oldUpdates = JSON.parse(state.val) || {};
                } catch (e) {
                    oldUpdates = {};
                    this.log.warn(`Cannot parse info.updatesJson: ${e}`);
                }
            } else {
                oldUpdates = {};
            }

            Object.keys(sources).forEach(name => {
                try {
                    if (installed[name]?.version && sources[name].version) {
                        if (
                            sources[name].version !== installed[name].version &&
                            !this.upToDate(sources[name].version, installed[name].version)
                        ) {
                            // Check if updates are new or already known to user
                            if (
                                !oldUpdates ||
                                !oldUpdates[name] ||
                                oldUpdates[name].availableVersion !== sources[name].version
                            ) {
                                newUpdateIndicator = true;
                            } // endIf
                            updatesJson[name] = {
                                availableVersion: sources[name].version,
                                installedVersion: installed[name].version,
                            };
                            // remove first part of the name
                            const n = name.indexOf('.');
                            list.push(n === -1 ? name : name.substring(n + 1));
                        }
                    }
                } catch (err) {
                    this.log.warn(`Error on version check for ${name}: ${err}`);
                }
            });

            this.setState('info.updatesNumber', list.length, true);
            this.setState('info.updatesList', list.join(', '), true);
            this.setState('info.newUpdates', newUpdateIndicator, true);
            this.setState('info.updatesJson', JSON.stringify(updatesJson), true);
            this.setState('info.lastUpdateCheck', Date.now(), true);

            if (!newUpdateIndicator) {
                return;
            }

            const textArr = [];
            for (const [adapter, updateInfo] of Object.entries(updatesJson)) {
                const text = getAdapterUpdateText({
                    adapter,
                    installedVersion: updateInfo.installedVersion,
                    newVersion: updateInfo.availableVersion,
                    lang: systemLanguage,
                });

                textArr.push(text);
            }

            this.registerNotification('admin', 'adapterUpdates', textArr.join('\n'));
        });
    }

    initSocket(server: unknown, store: unknown): void {
        socket = new SocketAdmin(this.config, this, objects);
        socket.start(server, ws, {
            userKey: 'connect.sid',
            store,
            secret: this.secret,
        });

        // subscribe on all object changes
        socket.subscribe('objectChange', '*');

        this.getForeignObjectAsync('system.meta.uuid')
            .then(async obj => {
                if (obj?.native) {
                    try {
                        await socket.updateRatings();
                    } catch (error) {
                        this.log.error(`Cannot fetch ratings: ${error}`);
                    }
                }
            })
            .catch(error => this.log.error(`Cannot read UUID: ${error}`));
    }

    processTasks(): void {
        if (!this._running && this._tasks.length) {
            this._running = true;

            const obj = this._tasks.shift();
            if (!obj.acl || obj.acl.owner !== this.config.defaultUser) {
                obj.acl.owner = this.config.defaultUser;
                this.setForeignObject(obj._id, obj, () =>
                    setImmediate(() => {
                        this._running = false;
                        this.processTasks();
                    })
                );
            } else {
                setImmediate(() => {
                    this._running = false;
                    this.processTasks();
                });
            }
        }
    }

    async applyRightsToObjects(pattern: string, types: string[] | string): Promise<void> {
        if (typeof types === 'object') {
            for (const type of types) {
                this.applyRightsToObjects(pattern, type);
            }
        } else {
            try {
                const doc = await this.getObjectViewAsync('system', types, {
                    startkey: `${pattern}.`,
                    endkey: `${pattern}.\u9999`,
                });

                this._tasks = this._tasks || [];

                for (const row of doc.rows) {
                    this._tasks.push(row.value as ioBroker.AnyObject);
                }
                this.processTasks();
            } catch (e) {
                this.log.error(`Error applying rights to objects: ${e.message}`);
            }
        }
    }

    applyRights(): void {
        const promises: Promise<boolean>[] = [];
        this.config.accessAllowedConfigs = this.config.accessAllowedConfigs || [];
        this.config.accessAllowedTabs = this.config.accessAllowedTabs || [];

        this.config.accessAllowedConfigs.forEach(id =>
            promises.push(
                new Promise(resolve =>
                    this.getForeignObject(`system.adapter.${id}`, (err, obj) => {
                        if (obj?.acl && obj.acl.owner !== this.config.defaultUser) {
                            obj.acl.owner = this.config.defaultUser;
                            this.setForeignObject(`system.adapter.${id}`, obj, err => resolve(!err));
                        } else {
                            resolve(false);
                        }
                    })
                )
            )
        );

        this.config.accessAllowedTabs.forEach(id => {
            if (id.startsWith('devices.')) {
                // change rights of all alias.*
                this.applyRightsToObjects('alias', ['state', 'channel']);
            } else if (id.startsWith('javascript.')) {
                // change rights of all script.js.*
                this.applyRightsToObjects('javascript', ['script', 'channel']);
            } else if (id.startsWith('fullcalendar.')) {
                // change rights of all fullcalendar.*
                this.applyRightsToObjects('fullcalendar', ['schedule']);
            } else if (id.startsWith('scenes.')) {
                // change rights of all scenes.*
                this.applyRightsToObjects('scenes', ['state', 'channel']);
            }
        });

        Promise.all(promises).then(results => {
            const len = results.filter(r => !!r).length;
            if (len) {
                this.log.info(`Updated ${len} objects`);
            }
        });
    }

    /**
     * Read news from server and register them as notifications
     */
    async updateNews(): Promise<void> {
        if (this.timerNews) {
            clearTimeout(this.timerNews);
        }
        this.timerNews = null;

        this.checkNodeJsVersion().catch(e => this.log.warn(`Cannot check node.js versions: ${e}`));

        let oldNews: NewsMessage[];
        let newEtag;

        const oldEtag = (await this.getStateAsync('info.newsETag'))?.val;

        let etag;

        try {
            const res = await axios.get('https://iobroker.live/repo/news-hash.json', {
                timeout: 13_000,
                validateStatus: status => status < 400,
            });

            etag = res.data;
        } catch (e) {
            this.log.warn(`Cannot update news: ${e.response ? e.response.data : e.message || e.code}`);
        }

        let _newNews;

        if (etag && etag.hash !== oldEtag) {
            newEtag = etag.hash;

            try {
                const res = await axios.get('https://iobroker.live/repo/news.json', {
                    timeout: 14_000,
                    validateStatus: status => status < 400,
                });

                _newNews = res.data;
            } catch (e) {
                this.log.warn(`Cannot update news_: ${e.response ? e.response.data : e.message || e.code}`);
            }
        } else {
            newEtag = oldEtag;
            _newNews = [];
        }

        const newNews = Array.isArray(_newNews) ? _newNews : [];

        const newsState = await this.getStateAsync('info.newsFeed');

        try {
            oldNews = newsState?.val ? JSON.parse(newsState.val as string) : [];
        } catch {
            oldNews = [];
        }

        const originalOldNews = JSON.stringify(oldNews);

        const lastState = await this.getStateAsync('info.newsLastId');

        // find time of last ID
        let time = '';
        if (lastState?.val) {
            const item = oldNews.find(item => item.id === lastState.val);
            if (item) {
                time = item.created;
            }
        }

        try {
            // add all IDs newer than last seen
            newNews.forEach(item => {
                if (!lastState || !time || item.created > time) {
                    if (!oldNews.find(it => it.created === item.created)) {
                        oldNews.push(item);
                    }
                }
            });

            oldNews.sort((a, b) => (a.created > b.created ? -1 : a.created < b.created ? 1 : 0));

            // delete news older than 3 months
            let i;
            for (i = oldNews.length - 1; i >= 0; i--) {
                if (Date.now() - new Date(oldNews[i].created).getTime() > 180 * 24 * 3_600_000) {
                    oldNews.splice(i, 1);
                }
            }

            if (originalOldNews !== JSON.stringify(oldNews)) {
                await this.registerNewsNotifications(oldNews, lastState?.val as string);
                await this.setStateAsync('info.newsFeed', JSON.stringify(oldNews), true);
            }

            if (newEtag !== oldEtag) {
                await this.setStateAsync('info.newsETag', newEtag, true);
            }
        } catch (e) {
            this.log.error(`Cannot update news: ${e.message}`);
        }

        this.timerNews = setTimeout(() => this.updateNews(), 24 * ONE_HOUR_MS + 1);
    }

    /**
     * Add the news to the notification system
     *
     * @param messages sorted news
     * @param lastMessageId lastMessageId, all after this has already been seen
     */
    async registerNewsNotifications(messages: NewsMessage[], lastMessageId?: string): Promise<void> {
        const adapters = await this.getObjectViewAsync('system', 'adapter', {
            startkey: 'system.adapter.\u0000',
            endkey: 'system.adapter.\u9999',
        });

        const operatingSystem = os.platform();

        const instances = await this.getObjectViewAsync('system', 'instance', {
            startkey: 'system.adapter.\u0000',
            endkey: 'system.adapter.\u9999',
        });

        const activeRepo = (await this.getForeignObjectAsync('system.config'))?.common.activeRepo;
        const uuid = (await this.getForeignObjectAsync('system.meta.uuid'))?.native.uuid;
        const nodeVersion = process.version;
        const npmVersion = await this.getNpmVersion();

        const today = Date.now();
        for (const message of messages) {
            if (!message) {
                continue;
            }

            if (message.id === lastMessageId) {
                break;
            }
            let showIt = true;

            if (showIt && message['date-start'] && new Date(message['date-start']).getTime() > today) {
                showIt = false;
            } else if (showIt && message['date-end'] && new Date(message['date-end']).getTime() < today) {
                showIt = false;
            } else if (showIt && message.conditions && Object.keys(message.conditions).length > 0) {
                Object.keys(message.conditions).forEach(key => {
                    if (showIt) {
                        const adapter = adapters.rows.find(adapter => adapter.id === `system.adapter.${key}`);
                        const condition = message.conditions[key];

                        if (!adapter && condition !== '!installed') {
                            showIt = false;
                        } else if (adapter && condition === '!installed') {
                            showIt = false;
                        } else if (adapter && condition === 'active') {
                            showIt = this.checkActive(key, instances);
                        } else if (adapter && condition === '!active') {
                            showIt = !this.checkActive(key, instances);
                        } else if (adapter?.value) {
                            showIt = this.checkConditions(condition, adapter.value.common.version);
                        }
                    }
                });
            }

            if (showIt && message['node-version']) {
                showIt = this.checkConditions(message['node-version'], nodeVersion);
            }
            if (showIt && message['npm-version']) {
                showIt = this.checkConditions(message['npm-version'], npmVersion);
            }
            if (showIt && message.os) {
                showIt = operatingSystem === message.os;
            }
            if (showIt && message.repo) {
                // If multi-repo
                if (Array.isArray(activeRepo)) {
                    showIt = activeRepo.includes(message.repo);
                } else {
                    showIt = activeRepo === message.repo;
                }
            }
            if (showIt && message.uuid) {
                if (Array.isArray(message.uuid)) {
                    showIt = uuid && message.uuid.find(msgUuid => uuid === msgUuid);
                } else {
                    showIt = !!(uuid && uuid === message.uuid);
                }
            }

            if (showIt && message['number-of-objects']) {
                const res = await this.getObjectListAsync({ include_docs: true });
                const noObjects = res.rows.length;

                showIt = eval(`${noObjects} ${message['number-of-objects']}`);
            }

            if (showIt && message['objects-db-type']) {
                const objectsDbType = await this.getObjectsDbType();

                if (!message['objects-db-type'].includes(objectsDbType)) {
                    showIt = false;
                }
            }

            if (showIt) {
                this.log.info(`register notification ${message.class}`);
                await this.registerNotification(
                    'admin',
                    `${message.class}News`,
                    `${message.title.en}\n${message.content.en}`
                );
            }
        }
    }

    /**
     * Check if adapter is active
     *
     * @param adapterName
     * @param instances
     */
    checkActive(
        adapterName: string,
        instances: Awaited<ioBroker.GetObjectViewPromise<ioBroker.InstanceObject>>
    ): boolean {
        return !!Object.keys(instances)
            .filter(id => id.startsWith(`adapter.system.${adapterName}.`))
            .find(id => instances.rows.find(row => id === row.id)?.value?.common.enabled);
    }

    /**
     * Check if conditions met
     *
     * @param condition
     * @param installedVersion
     */
    checkConditions(condition: string, installedVersion: string): boolean {
        if (condition.startsWith('equals')) {
            const vers = condition.substring(7, condition.length - 1).trim();
            return installedVersion === vers;
        }
        if (condition.startsWith('bigger') || condition.startsWith('greater')) {
            const vers = condition.substring(7, condition.length - 1).trim();
            try {
                return semver.gt(vers, installedVersion);
            } catch {
                return false;
            }
        } else if (condition.startsWith('smaller')) {
            const vers = condition.substring(8, condition.length - 1).trim();
            try {
                return semver.lt(installedVersion, vers);
            } catch {
                return false;
            }
        } else if (condition.startsWith('between')) {
            const vers1 = condition.substring(8, condition.indexOf(',')).trim();
            const vers2 = condition.substring(condition.indexOf(',') + 1, condition.length - 1).trim();
            try {
                return semver.gte(installedVersion, vers1) && semver.lte(installedVersion, vers2);
            } catch {
                return false;
            }
        } else {
            return true;
        }
    }

    /**
     * Get the objects db type
     */
    async getObjectsDbType(): Promise<string> {
        const diagData = await this.sendToHostAsync(this.host, 'getDiagData', 'normal');
        // @ts-expect-error messages are special and cannot be typed easily
        return diagData.objectsType;
    }

    /**
     * Get current npm version from controller
     */
    async getNpmVersion(): Promise<string> {
        const hostInfo = await this.sendToHostAsync(this.host, 'getHostInfo', {});
        // @ts-expect-error messages are special and cannot be typed easily
        return hostInfo.NPM;
    }

    async checkNodeJsVersion(): Promise<void> {
        // allow only one admin instance to check the versions for every host
        if (this.instance !== 0) {
            const objs = await this.getObjectViewAsync('system', 'instance', {
                startkey: 'system.adapter.admin.',
                endkey: 'system.adapter.admin.\u9999',
            });
            let min = null;
            // find the lowest active instance on the same host
            for (const row of objs.rows) {
                const obj = row.value;
                if (obj?.common.enabled && obj.common.host === this.host) {
                    const instance = parseInt(row.id.split('.').pop());
                    if (min === null || min < instance) {
                        min = instance;
                    }
                }
            }
            if (this.instance !== min) {
                return;
            }
        }

        const response = await axios<NodeVersionInformation[]>('https://nodejs.org/download/release/index.json');
        const result = {
            nodeNewest: '',
            nodeNewestNext: '',
            npmNewest: '',
            npmNewestNext: '',
            npmCurrent: '',
            nodeCurrent: process.version,
        };

        try {
            result.npmCurrent = await this.getNpmVersion();
        } catch (error) {
            this.log.warn(`Cannot get current npm version: ${error}`);
        }

        // https://nodejs.org/download/release/index.json
        // detect a new version of the same major version and new major version (that is allowed by ioBroker)
        try {
            const recommendedVersions = await this.getRecommendedVersions();
            // find newest suggested version
            const nodeNewestNext = response.data.find(item => item.version.startsWith(`v${recommendedVersions.node}.`));
            const nodeCurrentMajor = process.version.split('.')[0];
            const nodeNewest = response.data.find(item => item.version.startsWith(`${nodeCurrentMajor}.`));
            if (nodeNewestNext) {
                result.nodeNewestNext = nodeNewestNext.version;
            }
            if (nodeNewest) {
                result.nodeNewest = nodeNewest.version;
            }

            // find newest suggested version
            const npmNewestNext =
                nodeNewestNext || response.data.find(item => item.npm.startsWith(`${recommendedVersions.npm}.`));
            const npmNewest = response.data.find(item => item.version === process.version);
            if (npmNewestNext) {
                result.npmNewestNext = npmNewestNext.npm;
            }
            if (npmNewest) {
                result.npmNewest = npmNewest.npm;
            }

            const prefix = `system.host.${this.host}.versions`;

            await this.setForeignObjectNotExistsAsync(prefix, {
                type: 'channel',
                common: {
                    name: {
                        en: 'Node.js/Npm versions',
                        de: 'Node.js/Npm Versionen',
                        ru: 'Node.js/Npm версии',
                        pt: 'Versões Node.js/Npm',
                        nl: 'Node.js/Npm versions',
                        fr: 'Node.js/Npm versions',
                        it: 'Node.js/Npm versioni',
                        es: 'Node.js/Npm versiones',
                        pl: 'Wersja node.js/Npm',
                        uk: 'Версії Node.js/Npm',
                        'zh-cn': '页: 1',
                    },
                },
                native: {},
            });

            const states: ioBroker.SettableStateObject[] = [
                {
                    _id: 'nodeCurrent',
                    type: 'state',
                    common: {
                        role: 'state',
                        name: {
                            en: 'Current node.js version',
                            de: 'Aktuelle node.js Version',
                            ru: 'Текущая версия node.js',
                            pt: 'Versão atual do node.js',
                            nl: 'Current Node',
                            fr: 'Version actuelle node.js',
                            it: 'Versione attuale node.js',
                            es: 'Versión actual node.js',
                            pl: 'Aktualna wersja.js',
                            uk: 'Поточна версія вузла',
                            'zh-cn': '目前没有。',
                        },
                        type: 'string',
                        read: true,
                        write: false,
                        def: '',
                    },
                    native: {},
                },
                {
                    _id: 'nodeNewest',
                    type: 'state',
                    common: {
                        role: 'state',
                        name: {
                            en: 'Newest node.js version',
                            de: 'Neueste node.js Version',
                            ru: 'Новейшая версия node.js',
                            pt: 'Mais recente versão node.js',
                            nl: 'Nieuwste node',
                            fr: 'Nouvelle version node.js',
                            it: 'Nuova versione node.js',
                            es: 'Versión más reciente node.js',
                            pl: 'Najnowsza wersja węzła.js',
                            uk: 'Остання версія вузла',
                            'zh-cn': '最新版本',
                        },
                        type: 'string',
                        read: true,
                        write: false,
                        def: '',
                    },
                    native: {},
                },
                {
                    _id: 'nodeNewestNext',
                    type: 'state',
                    common: {
                        role: 'state',
                        name: {
                            en: 'Newest next major node.js version',
                            de: 'Neueste nächste große node.js Version',
                            ru: 'Новейшая следующая версия node.js',
                            pt: 'Mais nova versão principal node.js',
                            nl: 'Nieuwste volgende grote node',
                            fr: 'Nouvelle prochaine version node.js',
                            it: 'Nuova versione principale node.js',
                            es: 'Versión más reciente node.js',
                            pl: 'Najnowsza wersja węzła.js',
                            uk: 'Новейшая наступна версія вузла',
                            'zh-cn': '今后最新的重要内容。',
                        },
                        type: 'string',
                        read: true,
                        write: false,
                        def: '',
                    },
                    native: {},
                },
                {
                    _id: 'npmCurrent',
                    type: 'state',
                    common: {
                        role: 'state',
                        name: {
                            en: 'Current npm version',
                            de: 'Aktuelle Version',
                            ru: 'Текущая версия npm',
                            pt: 'Versão actual npm',
                            nl: 'Current Npm versie',
                            fr: 'Version actuelle npm',
                            it: 'Versione npm attuale',
                            es: 'Versión actual npm',
                            pl: 'Aktualna wersja',
                            uk: 'Поточна версія npm',
                            'zh-cn': '目前的印本',
                        },
                        type: 'string',
                        read: true,
                        write: false,
                        def: '',
                    },
                    native: {},
                },
                {
                    _id: 'npmNewest',
                    type: 'state',
                    common: {
                        role: 'state',
                        name: {
                            en: 'Newest npm version',
                            de: 'Neueste Version',
                            ru: 'Новейшая версия npm',
                            pt: 'Versão mais recente npm',
                            nl: 'Newest Npm versie',
                            fr: 'Nouvelle version npm',
                            it: 'Nuova versione npm',
                            es: 'Versión más reciente npm',
                            pl: 'Wersja nowa',
                            uk: 'Остання версія npm',
                            'zh-cn': '最新版本',
                        },
                        type: 'string',
                        read: true,
                        write: false,
                        def: '',
                    },
                    native: {},
                },
                {
                    _id: 'npmNewestNext',
                    type: 'state',
                    common: {
                        role: 'state',
                        name: {
                            en: 'Newest next major NPM version',
                            de: 'Neueste nächste große NPM-Version',
                            ru: 'Новейшая следующая крупная версия NPM',
                            pt: 'Mais nova versão principal do NPM',
                            nl: 'NPM',
                            fr: 'La version la plus récente',
                            it: 'Nuova versione NPM',
                            es: 'Versión NPM más reciente',
                            pl: 'Nowa wersja NPM',
                            uk: 'Новейша наступна велика версія NPM',
                            'zh-cn': '下一次主要国家预防计划',
                        },
                        type: 'string',
                        read: true,
                        write: false,
                        def: '',
                    },
                    native: {},
                },
            ];

            for (const state of states) {
                await this.setForeignObjectNotExistsAsync(`${prefix}.${state._id}`, state);
            }
            for (const [key, value] of Object.entries(result)) {
                await this.setForeignStateAsync(`${prefix}.${key}`, value.replace(/^v/, ''), true);
            }
        } catch {
            this.log.warn('Cannot check node.js/npm version');
        }
    }

    getData(callback: (adapter: typeof this) => void): void {
        this.log.info('requesting all objects');

        this.getObjectList({ include_docs: true }, (err, res) => {
            this.log.info('received all objects');
            if (res) {
                objects = {};
                let tmpPath = '';
                for (const row of res.rows) {
                    objects[row.doc._id] = row.doc as ioBroker.StateObject;
                    if (row.doc.type === 'instance' && row.doc.common?.tmpPath) {
                        if (tmpPath) {
                            this.log.warn('tmpPath has multiple definitions!!');
                        }
                        tmpPath = row.doc.common.tmpPath;
                    }
                }

                // Some adapters want access on specified tmp directory
                if (tmpPath) {
                    this.config.tmpPath = tmpPath;
                    this.config.tmpPathAllow = true;
                }

                this.createUpdateInfo().then(() => this.writeUpdateInfo());
            }

            if (callback) {
                callback(this);
            }
        });
    }

    async checkRevokedVersions(repository: Record<string, ioBroker.RepositoryJsonAdapterContent>): Promise<void> {
        try {
            const adapters = Object.keys(repository);
            const instances = await this.getObjectViewAsync('system', 'instance', {
                startkey: 'system.adapter.',
                endkey: 'system.adapter.\u9999',
            });

            for (const _adapter of adapters) {
                if (repository[_adapter].blockedVersions) {
                    // read a current version
                    if (Array.isArray(repository[_adapter].blockedVersions)) {
                        const instance = instances.rows.find(
                            item => item.value?.common.name === _adapter && item.value.common.enabled
                        );
                        if (instance?.value?.common?.version) {
                            for (let i = 0; i < repository[_adapter].blockedVersions.length; i++) {
                                try {
                                    if (
                                        semver.satisfies(
                                            instance.value.common.version,
                                            repository[_adapter].blockedVersions[i]
                                        )
                                    ) {
                                        // stop all instances
                                        for (let k = 0; k < instances.rows.length; k++) {
                                            const obj = instances.rows[k].value;
                                            if (obj?.common.enabled && obj.common.name === _adapter) {
                                                obj.common.enabled = false;
                                                await this.setForeignObjectAsync(obj._id, obj);
                                                this.log.warn(
                                                    `Instance ${obj._id.replace(
                                                        'system.adapter.',
                                                        ''
                                                    )} was disabled because blocked. Please update ${_adapter} to newer or available version`
                                                );
                                                this.sendToHost(obj.common.host, 'addNotification', {
                                                    scope: 'system',
                                                    category: 'accessErrors', // change to 'blocked' when js-controller 4.1. released
                                                    instance: obj._id,
                                                    message: `Instance version was blocked. Please check for updates and update before restarting the instance`,
                                                });
                                            }
                                        }
                                    }
                                } catch {
                                    this.log.error(
                                        `Cannot check revoked versions: ${repository[_adapter].blockedVersions[i]}`
                                    );
                                    // ignore
                                }
                            }
                        }
                    } else {
                        this.log.error(
                            `Invalid blockedVersions for ${_adapter}: ${JSON.stringify(
                                repository[_adapter].blockedVersions
                            )}. Expected array like ["<= 3.17.4"] or also ["~3.14.0", "~3.15.0", "~3.16.0"]`
                        );
                    }
                }
            }
        } catch (e) {
            this.log.error(`Cannot check revoked versions: ${e}`);
        }
    }

    // update icons by all known default objects. Remove this function after 2 years (BF: 2021.04.20)
    updateIcons(): void {
        if (fs.existsSync(`${utils.controllerDir}/io-package.json`)) {
            const ioPackage = JSON.parse(
                fs.readFileSync(path.join(utils.controllerDir, 'io-package.json'), {
                    encoding: 'utf-8',
                })
            );

            ioPackage.objects.forEach(async (obj: ioBroker.AnyObject) => {
                if (obj.common?.icon && obj.common.icon.length > 50) {
                    const cObj = await this.getForeignObjectAsync(obj._id);
                    if (cObj?.common && (!cObj.common.icon || cObj.common.icon.length < 50)) {
                        this.log.debug(`Update icon for ${cObj._id}`);
                        cObj.common.icon = obj.common.icon;
                        await this.setForeignObjectAsync(cObj._id, cObj);
                    }
                }
            });
        }
    }

    restartRepoUpdate(): void {
        // start the next cycle
        if (this.config.autoUpdate) {
            if (this.timerRepo) {
                clearTimeout(this.timerRepo);
                this.timerRepo = null;
            }
            this.log.debug(
                `Next repo update on ${new Date(
                    Date.now() + this.config.autoUpdate * ONE_HOUR_MS + 1
                ).toLocaleString()}`
            );
            this.timerRepo = setTimeout(
                () => {
                    this.timerRepo = null;
                    this.updateRegister();
                },
                this.config.autoUpdate * ONE_HOUR_MS + 1
            );
        }
    }

    getRecommendedVersions(): Promise<{ node: number; npm: number }> {
        return new Promise(resolve =>
            this.sendToHost(this.host, 'getRepository', {}, repository => {
                const repoInfo: {
                    repoTime: string;
                    recommendedVersions: {
                        nodeJsRecommended: number;
                        npmRecommended: number;
                    };
                    // @ts-expect-error fix later
                } = (repository as unknown)?._repoInfo;

                if (repoInfo?.recommendedVersions) {
                    resolve({
                        node: repoInfo.recommendedVersions?.nodeJsRecommended,
                        npm: repoInfo.recommendedVersions?.npmRecommended,
                    });
                } else {
                    resolve({
                        node: CURRENT_MAX_MAJOR_NODEJS,
                        npm: CURRENT_MAX_MAJOR_NPM,
                    });
                }
            })
        );
    }

    /**
     * Read repository information from active repository
     */
    updateRegister(): void {
        if (lastRepoUpdate && Date.now() - lastRepoUpdate < 3600000) {
            this.log.error('Automatic repository update is not allowed more than once a hour');
            this.restartRepoUpdate();
            return;
        }

        lastRepoUpdate = Date.now();

        this.getForeignObject('system.config', async (err, systemConfig) => {
            if (err) {
                this.log.error('May not read "system.config"');
            }

            if (systemConfig?.common) {
                try {
                    const repos = await this.getForeignObjectAsync('system.repositories');
                    if (!repos || repos.ts === undefined) {
                        // start the next cycle
                        this.restartRepoUpdate();
                        return;
                    }

                    // Check if repositories exist
                    let exists = false;
                    const active = systemConfig.common.activeRepo;

                    // if repo is valid and actual
                    if (Array.isArray(active)) {
                        if (
                            !err &&
                            Date.now() < repos.ts + this.config.autoUpdate * ONE_HOUR_MS &&
                            !active.find(repo => !repos?.native?.repositories?.[repo]?.json)
                        ) {
                            exists = true;
                        }
                    } else if (
                        !err &&
                        repos?.native?.repositories?.[active]?.json &&
                        Date.now() < repos.ts + this.config.autoUpdate * ONE_HOUR_MS
                    ) {
                        exists = true;
                    }
                    if (!exists) {
                        this.log.info('Request actual repository...');
                        // first check if the host is running
                        const aliveState = await this.getForeignStateAsync(`system.host.${this.host}.alive`);
                        if (!aliveState || !aliveState.val) {
                            this.log.error('Host is not alive');
                            // start the next cycle
                            this.restartRepoUpdate();
                            return;
                        }

                        // request repo from host
                        this.sendToHost(
                            this.host,
                            'getRepository',
                            {
                                repo: active,
                                update: true,
                            },
                            _repository => {
                                // @ts-expect-error fix later
                                if (_repository === ERROR_PERMISSION) {
                                    this.log.error('May not read "getRepository"');
                                } else {
                                    this.log.info('Repository received successfully.');

                                    socket?.repoUpdated();
                                    this.checkRevokedVersions(
                                        _repository as unknown as Record<string, ioBroker.RepositoryJsonAdapterContent>
                                    ).catch(e => this.log.error(`Cannot check revoked versions: ${e}`));
                                }

                                // start the next cycle
                                this.restartRepoUpdate();
                            }
                        );
                    } else if (this.config.autoUpdate) {
                        let interval = repos.ts + this.config.autoUpdate * ONE_HOUR_MS - Date.now() + 1;
                        if (interval > 0x7fffffff) {
                            interval = 0x7fffffff;
                        }
                        this.log.debug(`Next repo update on ${new Date(Date.now() + interval).toLocaleString()}`);
                        if (this.timerRepo) {
                            clearTimeout(this.timerRepo);
                        }
                        this.timerRepo = setTimeout(() => {
                            this.timerRepo = null;
                            this.updateRegister();
                        }, interval);
                    }
                } catch (err) {
                    this.log.error(`May not read "system.repositories": ${err}`);
                }
            }
        });
    }

    // this function re-check if the common objects like '0_userdata.0' exist
    async checkCommonObjects(): Promise<void> {
        // try to find js-controller directory
        let objects: ioBroker.Object[];
        try {
            const dir = require.resolve('iobroker.js-controller/io-package.json').replace(/\\/g, '/');
            // dir is something like ./node_modules/iobroker.js-controller/build/cjs/main.js
            if (fs.existsSync(dir)) {
                const data = JSON.parse(fs.readFileSync(dir).toString());
                if (data.objects) {
                    objects = data.objects;
                }
            }
        } catch {
            // ignore
        }
        if (objects) {
            for (let i = 0; i < objects.length; i++) {
                const obj = await this.getForeignObjectAsync(objects[i]._id);
                if (!obj) {
                    await this.setForeignObjectAsync(objects[i]._id, objects[i]);
                }
            }
        } else {
            // check the meta-object 0_userdata.0 and create it if required
            let userData: ioBroker.MetaObject | null | undefined = await this.getForeignObjectAsync('0_userdata.0');
            if (!userData) {
                userData = {
                    _id: '0_userdata.0',
                    type: 'meta',
                    common: {
                        icon: 'data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIGhlaWdodD0iMjRweCIgdmlld0JveD0iMCAwIDI0IDI0IiB3aWR0aD0iMjRweCI+DQogICAgPGcgZmlsbD0iY3VycmVudENvbG9yIj4NCiAgICAgICAgPHBhdGggZD0iTTE5LDV2MTRINVY1SDE5IE0xOSwzSDVDMy45LDMsMywzLjksMyw1djE0YzAsMS4xLDAuOSwyLDIsMmgxNGMxLjEsMCwyLTAuOSwyLTJWNUMyMSwzLjksMjAuMSwzLDE5LDNMMTksM3oiLz4NCiAgICAgICAgPHBhdGggZD0iTTE0LDE3SDd2LTJoN1YxN3ogTTE3LDEzSDd2LTJoMTBWMTN6IE0xNyw5SDdWN2gxMFY5eiIvPg0KICAgIDwvZz4NCjwvc3ZnPg==',
                        name: {
                            en: 'User objects and files root folder',
                            de: 'Stammordner für Benutzerobjekte und Dateien',
                            ru: 'Корневая папка пользовательских объектов и файлов',
                            pt: 'Pasta raiz de objetos e arquivos do usuário',
                            nl: 'Hoofdmap van objecten en bestanden van gebruikers',
                            fr: 'Objets utilisateur et dossier racine des fichiers',
                            it: "Cartella principale di oggetti e file dell'utente",
                            es: 'Carpeta raíz de objetos y archivos de usuario',
                            pl: 'Folder główny obiektów i plików użytkownika',
                            uk: "Коренева папка об'єктів користувача та файлів",
                            'zh-cn': '用户对象和文件根文件夹',
                        },
                        desc: {
                            en: 'Here you can upload your files or create your private objects and states',
                            de: 'Hier können eigene Dateien hochgeladen oder private Objekte und Zustände erstellt werden',
                            ru: 'Здесь вы можете загрузить свои файлы или создать свои личные объекты и состояния',
                            pt: 'Aqui você pode enviar seus arquivos ou criar seus objetos e estados particulares',
                            nl: 'Hier kunt u uw bestanden uploaden of uw privé-objecten en statussen maken',
                            fr: 'Ici, vous pouvez télécharger vos fichiers ou créer vos objets et états privés',
                            it: 'Qui puoi caricare i tuoi file o creare oggetti e stati privati',
                            es: 'Aquí puede cargar sus archivos o crear sus objetos y estados privados',
                            pl: 'Tutaj możesz przesyłać pliki lub tworzyć prywatne obiekty i stany',
                            uk: "Тут ви можете завантажити свої файли або створити свої приватні об'єкти та стани",
                            'zh-cn': '在这里您可以上传文件或创建私有对象和状态',
                        },
                        type: 'meta.user',
                        dontDelete: true,
                    },
                    acl: {
                        owner: 'system.user.admin',
                        ownerGroup: 'system.group.administrator',
                        object: 1604,
                    },
                } as ioBroker.MetaObject;

                this.setForeignObject(userData._id, userData);
            }
        }
    }

    /**
     * Initialize the adapter
     */
    init(): void {
        this.config.defaultUser = this.config.defaultUser || 'admin';
        if (!this.config.defaultUser.match(/^system\.user\./)) {
            this.config.defaultUser = `system.user.${this.config.defaultUser}`;
        }

        this.checkCommonObjects().catch((e: unknown) => this.log.warn(`Cannot check common objects: ${e}`));

        this.getData(
            adapter => (webServer = new Web(adapter.config, adapter, this.initSocket.bind(this), { systemLanguage }))
        );

        if (
            this.config.accessApplyRights &&
            this.config.accessLimit &&
            !this.config.auth &&
            this.config.defaultUser !== 'system.user.admin'
        ) {
            this.applyRights();
        }

        // By default, update repository every 24 hours
        if (this.config.autoUpdate === undefined || this.config.autoUpdate === null) {
            this.config.autoUpdate = 24;
        }

        // interval in hours
        this.config.autoUpdate = Number(this.config.autoUpdate) || 0;
        if (this.config.autoUpdate && this.config.autoUpdate < 4) {
            this.config.autoUpdate = 4; // only every 4 hours - it is a minimal update interval
        } else if (this.config.autoUpdate > 590) {
            // 0x7FFFFFFF / ONE_HOUR_MS = 596
            this.config.autoUpdate = 590; // max interval is 2147483647 milliseconds
        }

        // check info.connected
        this.getObjectAsync('info.connected').then(obj => {
            if (!obj) {
                const packageJson = JSON.parse(fs.readFileSync(`${__dirname}/../io-package.json`).toString('utf8'));
                const obj = packageJson.instanceObjects.find((o: ioBroker.AnyObject) => o._id === 'info.connected');
                if (obj) {
                    return this.setObjectAsync(obj._id, obj);
                }
            }
        });

        if (this.config.autoUpdate) {
            this.updateRegister();
        }

        this.updateNews();
        this.updateIcons();
        this.validateUserData0();
    }

    /**
     * Create 0_userdata if it does not exist
     */
    validateUserData0(): void {
        this.getForeignObject('0_userdata.0', (err, obj) => {
            if (!obj) {
                try {
                    const ioContent = fs.readFileSync(`${utils.controllerDir}/io-package.json`).toString('utf8');
                    const io = JSON.parse(ioContent);
                    if (io.objects) {
                        const userData = io.objects.find((obj: ioBroker.AnyObject) => obj._id === '0_userdata.0');
                        if (userData) {
                            this.setForeignObject(userData._id, userData, () =>
                                this.log.info('Object 0_userdata.0 was re-created')
                            );
                        }
                    }
                } catch (e) {
                    this.log.error(`Cannot read ${utils.controllerDir}/io-package.json: ${e}`);
                }
            }
        });
    }
}

if (require.main !== module) {
    // Export the constructor in compact mode
    module.exports = (options: Partial<utils.AdapterOptions> | undefined) => new Admin(options);
} else {
    // otherwise start the instance directly
    (() => new Admin())();
}
